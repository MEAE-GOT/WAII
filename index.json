[
{
	"uri": "https://w3c.github.io/automotive-viss2/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://w3c.github.io/automotive-viss2/pocs/poc2/",
	"title": "Next POC...",
	"tags": [],
	"description": "",
	"content": "The presentation\u0026hellip;\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://w3c.github.io/automotive-viss2/pocs/poc1/",
	"title": "Vehicle.Speed subscription example",
	"tags": [],
	"description": "",
	"content": "Here follows a minimal example that goes through all the steps nneeded to set up a VISSv2 tech stack where a client subscribes to Vehicle.Speed, and receives simulated values in return.\nIt is assumed that the development environment has Golang installed. If not, then instruction for installing Golang is found here.\nIf this repo is not cloned to the development environment, this is done by the command:\n$ git clone https://github.com/w3c/automotive-viss2.git\nThe POC will be based on the feeder found at the feeder branch, so switching to this branch is done by the command:\n$ git checkout feeder\nAs we will use the Redis based statestorage, we will have to start the Redis daemon. A code snippet that does this is available here. If you do not already have cloned this repo, then it is done by the command:\n$ git clone https://github.com/COVESA/ccs-components\nCheck out the README here for details on how to set this up.\nNext is to build the server, which is done in a terminal window by the command (with the working directory moved to the WAII/server/vissv2server):\n$ go build\nThe server uses a binary formatted copy of the VSS tree to verify client requests, so if the signal of interest, Vehicle.Speed, is not in this tree, i is necessary to create a new binary tree containing this signal. For informtion on how to get tht done, check out [/automotive-viss2/server#vss-tree-configuration).\nThen start the server with the command line configuration for using Redis as statestorage:\n$ ./vissv2server -s redis\nTo build the feeder, open a new terminal and move the working directory to WAII/feeder and then apply the command:\n$ go build\nBefore strtign it, it needs to be configured for mapping of the Vehicle.Speed signal, and to generate simulated values for it. To do this the file VehicleVssMapData.json needs to be edited so that it only contains a mapping for Vehicle.Speed.\n[{\u0026ldquo;vssdata\u0026rdquo;:\u0026ldquo;Vehicle.Speed\u0026rdquo;,\u0026ldquo;vehicledata\u0026rdquo;:\u0026ldquo;CurrSpd\u0026rdquo;}]\nReplace the content of the file with the above. The name \u0026lsquo;CurrSdp\u0026rsquo; is the (imaginary) name of the speed signal used in the vehicle interface. After the feeder is configured it is started:\n$ ./feeder\nWhat is left now is to start a client and issue the subscribe request. One solution to this is to write a client, but a quicker solution is to use any of the existing clients.\nWe will here use the Javascript based client that uses the Websocket protocol.\nStart it by navigating to the directory using a file browser, then just click on it.\nAs the first field to populate is the field requesting the Ip address / URL of the server, it is necessary to find this for the computer it runs on. This can on Ubuntu be done with the command:\n$ ip addr show\nthen search for an IP address shown after the word \u0026ldquo;inet\u0026rdquo;.\nCopy the address into the field and push the Server IP button.\nThe client should then be connected to the server, which is verified b a printout in this browser tab saying \u0026ldquo;Connected\u0026rdquo;. If that is not shown, either the server is not up and running, or the IP address is not the corrt one.\nAssuming it got connected, the only thing left is to issue a subscribe request. The appclient_commands.txt contains many examples of client requests\nFrom this file, copy the request payload:\n{\u0026ldquo;action\u0026rdquo;:\u0026ldquo;subscribe\u0026rdquo;,\u0026ldquo;path\u0026rdquo;:\u0026ldquo;Vehicle/Cabin/Door/Row1/Right/IsOpen\u0026rdquo;,\u0026ldquo;filter\u0026rdquo;:{\u0026ldquo;type\u0026rdquo;:\u0026ldquo;timebased\u0026rdquo;,\u0026ldquo;parameter\u0026rdquo;:{\u0026ldquo;period\u0026rdquo;:\u0026ldquo;3000\u0026rdquo;}},\u0026ldquo;requestId\u0026rdquo;:\u0026ldquo;246\u0026rdquo;}\nAnd then edit the path to become \u0026ldquo;path\u0026rdquo;:\u0026ldquo;Vehicle.Speed\u0026rdquo;, copy this updated payload, paste it into the payload field, and push the Send button.\nAfter about three seconds an event message should be received from the server and printed into the browser tab, looking something like: { \u0026ldquo;action\u0026rdquo;: \u0026ldquo;subscription\u0026rdquo;, \u0026ldquo;subscriptionId\u0026rdquo;: \u0026ldquo;1\u0026rdquo;, “data”: {“path”: ”Vehicle.Speed”, “dp”: {“value”: ”50.0”, “ts”: ”2023-04-15T13:37:00Z”}}, \u0026ldquo;ts\u0026rdquo;: \u0026ldquo;2023-04-15T13:37:00Z\u0026rdquo; } This should every three seconds be followed by a new event message. If the feeder was configured to update this signal with simulated values, the value shown should vary accordingly, else it will be the same in every event message. If there has not been any value written into the Redis statestorage for this signal, then the value will be \u0026ldquo;Data-not-available\u0026rdquo;.\nThe server will continue to send these event messages every third second until it receives an unsubscribe request containing the subscriptionId it associated to the subscription. To send an unsubscribe request, search for it in the appclient_commands.txt file, check that the subscriptionId is correct, paste it into the payload field and push the Send button. The event message printouts should then stop, and the POC is successfully ended.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/server/access-control-servers/",
	"title": "VISSv2 Access Control Servers",
	"tags": [],
	"description": "",
	"content": "The VISSv2 access control model specifies two authorization servers:\nAccess Grant server Access Token server Access Grant server This server is in a typical scenario running in the cloud. It is built as a separate executable in the WAII/server/agt_server directory\n$ go build\nand run by\n$ ./agt_server\nIt exposes an HTTP API according to the VISSv2 specification. However it is currently not TLS protected (which is a must in non-development scenario). What is also missing in the AGS implementation is authentication of the client, which according to the specification should be an AGT task.\nAccess Token server This server runs as a thread within the vissv2 server, so it is built by the vissv2 build command. For it to be built, it is necessary to make sure that the \u0026ldquo;atServer\u0026rdquo; line in the serverComponents array in the vissv2server.go code is uncommented:\nvar serverComponents []string = []string{ \u0026#34;serviceMgr\u0026#34;, \u0026#34;httpMgr\u0026#34;, \u0026#34;wsMgr\u0026#34;, \u0026#34;mqttMgr\u0026#34;, \u0026#34;grpcMgr\u0026#34;, \u0026#34;atServer\u0026#34;, } If it is part of the vissv2server build, and if a VSS node is access control tagged, the server will then forward the access token received in the client request to the ATS for validation.\nThe ATS will as part of the validation also use the VISSv2 specified policy documents if they are found in the working directory.\nThe ATS suports caching of access tokens, and returning a token handle to the client if cached. The cache is configured to hold max 10 tokens. If the cache is full, caching of one more is rejected until a cached token becomes expired, or pre-emptied by other reasons.\nServer configuration The configuration available for the servers is whether the protocols that they implement to expose their APIS are TLS protected or not. The same framework that is used for generating credentials for the client-server communication described here can be used in this case also. These credentials should however to follow good security practises be separate from what is used in the client-server communication. The different port number for the respective servers are shown below.\nServer Port number: No TLS Port number: TLS AGTS 7500 7443 ATS 8600 8443 VISS web client submodule This submodule implements a VISSv2 web client that exposes a UI that is considerably more sophisticated than what other clients on the WAII repo exposes, and it is particularly helpful when it comes to the client interactions with access control involved. Check out the README on both repos for more information.\nConsent support The VISSv2 specification provides support for requesting consent from a data owner before allowing a client to access the data. The model for this is that the process for obtaining the owner consent is delegated to an External Consent framework (ECF), and the details ofthis process is out-of-scope in relation to the VISSv2 specification. What is in scope is a high-level description of the protocol between the VISSv2 server and the ECF, see the VISSv2 consent support chapter. To configure the VISSv2 server to try to connect to an ECF, it must be started with the command parameter -c\u0026quot;.\nThe figure below shows the the different steps in the dataflow that is necessary when a client wants to initiate a subscription of data that is access controlled and require consent from the data owner. The dataflow describes a scenario when the client successfully subscribes to data the require both access control and consent by the data owner. Consent can only be required in combination with requiring access control, please see the Access Control Model chapter.\nThe client issues a request to the Access Grant Token server (AGTS). 1.1 The AGTS verifies the client request and returns an Access Grant Token (AGT).\nThe client issues a request to the Access Token server (ATS). 2.1 The ATS writes the data in the client request to the Pending list, associating a reference Id to it.\n2.2 The ATS issues a request to obtain consent to the ECF, including the reference Id.\n2.3 The ATS sends a response to the client containing a reference to the entry in the Pending list.\n2.4 The ECF has obtained (a positive) consent and issues a message to the ATS containing the consent and the reference Id. The ATS updates the consent info in the Pending list (initially set to NOT_SET).\n2.5 The client issues an inquiry request to the ATS containing the reference Id.\n2.6 The entry on the Pending list is used to generate the AT, is then deleted, and a new entry containing the AT, keeping the same reference Id, is created on the Active list.\n2.7 A response containing the AT is returned to the client. If the inquiry request 2.5 happened before 2.4 then the ATS returns the same reference Id without executing 2.6, but if 2.4 happened before, so that the consent no longer has the value NOT_SET, then if the consent was set to YES, the ATS generates the Access Token (AT), and returns it to the client. If the consent was set to NO, the consent data is returned without the AT.\nThe client issues the subscribe request to the VISSv2 server containing the AT. The AT in the client request my be represented by a handle instead of the entire AT, see the Protected Resource Request chapter. 3.1 The VISSv2 server issues an AT validation request to the ATS. The ATS finds it on the Active list, and validates the AT.\n3.2 The ATS returns the validation result to the VISSv2 server, and the reference Id from the matching entry on the Active list.\n3.3 Assuming a positive AT validation, the VISSv server forwards the client subscribe request, and the reference Id, to the service manager.\n3.4 The service manager creates an entry on the subscription list containing the required data for being able to issue event messages to the client containing the requested signals. The reference Id is also saved.\n3.5 and 3.6 The service manager creates the response message associated to the request in 3.\nFrom this point on the servicemanager will when the event described in the filter data from the client request is triggered issue event messges to the client. This will continue until any of the following happens:\nA. The client issues an unsubscribe request.\nB. The ECF issues a consent cancellation request to the ATS.\nC. The AT expiry time is reached.\nAlternative A: The service manager will delete the entry on the subscription list. The corresponding entry on the Active list will remain.\nAlternative B: The ATS will delete the entry on the Active list, and issue a request to the service manager to delete the entry on the subscription list corresponding to the reference Id from its deleted entry.\nAlternative C: The ATS will delete the entry on the Active list correspnding to the reference Id received from the ECF, and issue a request to the service manager to delete the entry on the subscription list corresponding to the reference Id.\nPayload syntax for the messages in the client-to-ATGS communication: AGT request: {“action”: “agt-request”, \u0026ldquo;vin\u0026rdquo;:\u0026ldquo;pseudo-vin\u0026rdquo;, \u0026ldquo;context\u0026rdquo;:\u0026ldquo;triplet-sub-roles-see-spec\u0026rdquo;, \u0026ldquo;proof\u0026rdquo;:\u0026ldquo;ABC\u0026rdquo;, \u0026ldquo;key\u0026rdquo;:\u0026ldquo;DEF\u0026rdquo;}\nAGT response: {“action”: “agt-request”, \u0026ldquo;token\u0026rdquo;:\u0026ldquo;x.y.z\u0026rdquo;} // if successful validation\nError response: {“action”: “agt-request”, \u0026ldquo;error\u0026rdquo;:\u0026ldquo;error-reason\u0026rdquo;} // if unsuccessful validation\nPayload syntax for the messages in the client-to-ATS communication: AT request: {“action”: “at-request”, \u0026ldquo;agToken\u0026rdquo;:\u0026ldquo;x.y.z\u0026rdquo;, \u0026ldquo;purpose\u0026rdquo;:\u0026ldquo;purpose-description\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;:\u0026quot;\u0026quot;} // pop shall be an empty string for access control short term flow.\nAT response 1: {“action”: “at-request”, \u0026ldquo;aToken\u0026rdquo;:\u0026ldquo;x.y.z\u0026rdquo;} ATS-\u0026gt;Client // Consent is not required.\nAT response 2: {“action”: “at-request”, \u0026ldquo;sessionId \u0026ldquo;:\u0026ldquo;reference-Id\u0026rdquo;, “consent”:”NOT_SET”} // Consent is required, and consent reply not obtained yet from ECF.\nAT inquiry request: {“action”: “at-inquiry”, \u0026ldquo;sessionId\u0026rdquo;:\u0026ldquo;reference-Id\u0026rdquo;} // may need to be issued multiple times until consent is provided by ECF.\nAT inquiry response 1: {“action”: “at-inquiry”, \u0026ldquo;aToken\u0026rdquo;:\u0026ldquo;x.y.z\u0026rdquo;, “consent”:”YES”} ATS-\u0026gt;Client // ECF has provided a positive consent.\nAT inquiry response 2: {“action”: “at-inquiry”, \u0026ldquo;sessionId \u0026ldquo;:\u0026ldquo;reference-Id\u0026rdquo;, “consent”:”NOT_SET”} // Reply is not obtained yet from ECF.\nAT inquiry response 3: {“action”: “at-inquiry”, “consent”:”NO”} // ECF has provided a negative consent.\nError response: {“action”: “same-as-in-request”, \u0026ldquo;error\u0026rdquo;:\u0026ldquo;error-reason\u0026rdquo;}\nPayload syntax for the messages in the ATS-to-ECF communication: Consent request: {“action”: “consent-ask”, “user-roles”: “triplet-sub-roles-see-spec”, “purpose”: “purpose-description”, \u0026ldquo;signal_access\u0026rdquo;: [{},..{}], “messageId”: ”reference-Id”}\nConsent reply request: {“action”: “consent-reply”, “consent”: “YES/NO”, “messageId”: ”reference-Id”}\nConsent cancellation request: {“action”: “consent-cancel”, “messageId”: ”reference-Id”}\nResponse to above requests: {“action”: “same-as-in-request”, “status”: “200-OK/404-Not found/401-Bad request”} // Status is one of the three examples shown.\nSee the specification chapterPurpose list for the definition of the signal_access object.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/client/",
	"title": "VISSv2 Clients",
	"tags": [],
	"description": "",
	"content": "There are a number of different clients avaliable on this repo in the client/client-1.0 directory.\nCompression client The compression client can be used for testing three payload compression variants.\nProprietary compression algorithm Protobuf encoding, level 1 Protobuf encoding, level 2 Proprietary compression algorithm This compression variant builds on a proprietary algorithm that takes advantage of knowing the VISSv2 payload format. Due to its strong dependence on the payload format it might require rewrites if/when the payload format is updated. It is not kept up to date on this and is therefore likely to crash if an unsupported payload is applied.\nProtobuf encoding The encoding uses the VISSv2messages.proto file found here. The server supports this only for the Websocket protocol, where the websocket transport manager encodes payloads before sending them, and decodes payloads directly after receiving them. The client follows the same encoding/decoding behavior, so that the use of protobuf encoding is abstracted before other layers in both the server and the client get access to the payloads. Two levels of protobuf encoding are available, level one in which paths and timestamps have the standardized text format, and level two where these fields are compressed.\nLevel 2 Level 2 compresses the VSS paths by using the VSS path list as a lookup table. Instead of using the string paths in the encoded payload the index into the array is used. Finding the index in the array for a given path is done by applying a binary search, as the array paths are sorted by the server. Going the other way, the array is simply indexed by the integer value from the protobuf encoded payload. The string based timestamps are replaced by an int32 as shown in the CompressTS() procedure found in computils.go. Level 2 achieves compression rates of around 5 or better.\ngRPC client The gRPC implementation uses the protobuf encoding in the VISSv2messages.proto file found here. The server currently only supports the protobuf level 1 encoding.\nMQTT client The MQTT client implements the application level protocol described in the specification.\nCSV client The CSV client is developed for testing the curve logging algorithm that Geotab has opened for public cuse. A client can equest it to be aplied to data by using a filter option.\nIt generates a comma separated (CSV) file in which it saves the curve logged data that it has reuested from the server. The CSV format makes it easy to import it into an Excel sheet and visualize it as a graph which allows it e. g. to be compared with the original, non-curved data.\nJava script clients There are a few clients that are written in Javascript, and thus when started opens in a browser. Thes clients can be quite handy for quick testing of the server functionality. Example payloads that can be used as input are found in the appclient_commands.txt file.\nHTTP client The HTTP Client requires the server IP address/URL to be written into the field for it, and the IP address button to be pushed. Thereafter paths can be written into the Get field, followed by a push of the Get button. In the case of the client writing a value to the server, the path is written into the Set field, with the value in the following field, before pushing the Post button. If the data associated with the path is access controlled, then the access token that must have been obtained via the dialogues with the two autorization servers must first be written into the field for the token. Klicking the button to the right of it preserves the token for use in multple requests.\nWebsocket client The Websocket Client requires the server IP address/URL to be written into the field for it, and the IP address button to be pushed. Thereafter JSON based payloads can be written into the Sed field, followed by a push of the Send button.\nWebsocket client (using compression) The Websocket Client requires the server IP address/URL to be written into the field for it, and the IP address button to be pushed. Thereafter JSON based payloads can be written into the Sed field, followed by a push of the Send button. The difference to the uncompressed Websocket client is that this client opens a Websocket session with the erver in which it requests a session in which proprietary compression is applied to the payloads (see chapter above).\nAccess Grant Token Server client The AGT client requests an Access Grant Token from the Access Grant Token server.\nIt requires the AGT server IP address/URL to be written into the field for it, and the Server IP button to be pushed. In the leftmost field below \u0026ldquo;agtserver\u0026rdquo; (no quotes) must be written, then in the rightmost field a request payload shall be written. A payload example can be found in the appclient_commands.txt file. The proof value must be \u0026ldquo;ABC\u0026rdquo; for a positive validation, in which case an Access Grant token is returned.\nAccess Token Server client The AT client requests an Access Token from the Access Token server.\nIt requires the AT server IP address/URL to be written into the field for it, and the Server IP button to be pushed. In the leftmost field below \u0026ldquo;atserver\u0026rdquo; (no quotes) must be written, then in the rightmost field a request payload shall be written. A payload example can be found in the appclient_commands.txt file. The token that is provided in the request must include an Access Grant token from the response of a successful reuquest to the AGT server.\nClients on other repos VISS Web Client The VISS web client exposes a sophisticated UI that includes support for the dialogues that a client needs to have with the authorization server in scenarios where access control is required.\nCCS client The CCS client uses either HTTP (for Get requests), or Websocket (for subscribe requests) to access data according to a list of paths in a config file, and then requesting an OVDS server to write this data into the OVDS database.\nCCS MQTT client The CCS MQTT client uses the VISSv2 MQTT based protocol to subscribe to data according to a list of paths in a config file, and then requesting an OVDS server to write this data into the OVDS database.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/docker-step-by-step/",
	"title": "VISSv2 Docker",
	"tags": [],
	"description": "",
	"content": "Intro This is a guide to setup and run the vissv2 server together with the remotiveLabs broker with recorded vehicle data. The data set is residing the remotiveLabs cloud - . There are some configuration files that needs to be set and pushed to the docker images. The docker-compose-rl.yml is depending on the Dockerfile(for building) also located in the project root. A docker directory is reserved for adding different docker setups with different data providers.\n1. feeder-rl\nThe feeder-rl has two basic commands which lets you switch dataprovider. We have \u0026ndash;dataprovider remotive or \u0026ndash;dataprovider sim. This guide will focus on using \u0026ndash;dataprovider remotive.\nVisit remotive labs cloud demo\nSelect the Turning Torso Drivecycle, and the vss configuration. Select Play, and choose select broker, choose My personal broker and then Upload. Select Go to broker In the left down corner select Broker details and copy the url and the api-key, we need them for the feeder configuration keep the page open in the browser (we will not press start yet) Edit the config.json in the feeder-rl directory, replace url and api key. { \u0026#34;tls\u0026#34;: \u0026#34;yes\u0026#34;, \u0026#34;cert_path_name\u0026#34;: \u0026#34;certificate.pem\u0026#34;, \u0026#34;name_spaces\u0026#34;: [\u0026#34;vss\u0026#34;], \u0026#34;broker_url\u0026#34;: \u0026#34;\u0026lt;broker url\u0026gt;\u0026#34;, \u0026#34;port\u0026#34;:\u0026#34;443\u0026#34;, \u0026#34;client_id\u0026#34; : \u0026#34;volvo-go-client\u0026#34;, \u0026#34;api_key\u0026#34;: \u0026#34;\u0026lt;api key\u0026gt;\u0026#34;, \u0026#34;vss_tree_path\u0026#34;: \u0026#34;../vss/vss-flat-json/normalized-json/vss_n.json\u0026#34;, \u0026#34;signalfilter\u0026#34;: [\u0026#34;Vehicle.Speed\u0026#34;,\u0026#34;Vehicle.Body.Lights.IsLeftIndicatorOn\u0026#34;,\u0026#34;Vehicle.VehicleIdentification.VIN\u0026#34;,\u0026#34;Vehicle.CurrentLocation.Latitude\u0026#34;,\u0026#34;Vehicle.CurrentLocation.Longitude\u0026#34;,\u0026#34;Vehicle.Chassis.Accelerator.PedalPosition\u0026#34;] } The signalfilter element contains the signals that we would like the broker to filter our for us. Save the file. NOTE:\nThe feeder uses the redis state storage database to handle incoming datapoints. The location of the database and its server socket communication file.\nrunning feeder-rl example:\nfeeder-rl --dataprovider remotive --rdb /tmp/docker/redisDB.sock --fch /tmp/docker/server-feeder-channel.sock For further details view the docker-compose-rl.yml located in the project root.\n2. server configuration\nThe server needs to know where it should forward its requests for writing or reading datapoints.\nEdit the file feeder-registration.json [ { \u0026#34;root\u0026#34;:\u0026#34;Vehicle\u0026#34;, \u0026#34;fname\u0026#34;:\u0026#34;/tmp/docker/server-feeder-channel.sock\u0026#34;, \u0026#34;db\u0026#34;: \u0026#34;/tmp/docker/redisDB.sock\u0026#34; } ] set the fname element to where the feeder channel socket file should reside. set the db element to where the redis database should reside. NOTE: The above file paths and file names are correct. Changing the location of these will require changes in the docker-compose yml.\n3. build and run\nlocate the docker-compose-rl.yml file in the project root build the docker containers: docker compose -f docker-compose-rl.yml build revisit the browser from step 1, press the start button, the recorded data playback starts. run the docker-compose: docker compose -f docker-compose-rl.yml up If you get the following output to the docker console you have succesfully connected and started the vissv2server:\nfeeder | {\u0026#34;file\u0026#34;:\u0026#34;feeder-rl.go:65\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Data written to statestorage: Name=Vehicle.Speed, Value=10.240000000000002\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-11-01T11:36:13Z\u0026#34;} feeder | {\u0026#34;file\u0026#34;:\u0026#34;feeder-rl.go:65\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Data written to statestorage: Name=Vehicle.Speed, Value=10.32\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-11-01T11:36:14Z\u0026#34;} feeder | {\u0026#34;file\u0026#34;:\u0026#34;feeder-rl.go:65\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Data written to statestorage: Name=Vehicle.Chassis.Accelerator.PedalPosition, Value=15.600000000000001\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-11-01T11:36:14Z\u0026#34;} feeder | {\u0026#34;file\u0026#34;:\u0026#34;feeder-rl.go:65\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Data written to statestorage: Name=Vehicle.Speed, Value=10.399999999999999\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-11-01T11:36:14Z\u0026#34;} feeder | {\u0026#34;file\u0026#34;:\u0026#34;feeder-rl.go:65\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Data written to statestorage: Name=Vehicle.Speed, Value=10.480000000000004\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-11-01T11:36:14Z\u0026#34;} feeder | {\u0026#34;file\u0026#34;:\u0026#34;feeder-rl.go:65\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Data written to statestorage: Name=Vehicle.Speed, Value=10.560000000000002\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-11-01T11:36:14Z\u0026#34;} feeder | {\u0026#34;file\u0026#34;:\u0026#34;feeder-rl.go:65\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Data written to statestorage: Name=Vehicle.Speed, Value=10.64\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-11-01T11:36:14Z\u0026#34;} "
},
{
	"uri": "https://w3c.github.io/automotive-viss2/peripheral-components/",
	"title": "VISSv2 peripheral components",
	"tags": [],
	"description": "",
	"content": "A few other software components that can be useful when setting up a VISSv2 communication tech stack exists:\nAuthorization servers for access control and consent models. Open Vehicle Data Set, a relational database with a table configuration that enables it to store time series of VSS data from multiple vehicles. A \u0026ldquo;live simulator\u0026rdquo; that can read vehicle trip data stored in an OVDS database , and replay it so that it appears as live data from the recorded trip. Access control authorization servers The VISS2 specification describes an access control model involving two authorization servers:\nAccess Grant Token server Access Token server For details please read the VISSv2: Access Control, and the Consent Model chapters. To trigger the access control and consent functionality it is necessary to tag the corresponding VSS nodes as described in the spec. This can either be done by editing of the actual vspec files from the VSS/spec directory, or by creating overlay files and include them as described in VSS-tools, and then generate the VSS tree in binary format as described in VSS tree configuration.\nAccess Grant Token server (AGTS) The AGTS, which typically will be deployed off-vehicle, in the cloud, is separately built and deployed. The file agt_public_key.rsa is generated at startup, which must be copied to the AT server directory.\nAccess Token server (ATS) The ATS is deployed on a separate thread within the VISSv2 server, to include it make sure it is uncommented in the serverComponents string array in viss2server.go. The ATS uses the policy documents described in the spec when validating an access token, examples of these are available in the purposelist.json and scopelist.json files.\nOpen Vehicle Data Set (OVDS) The code to realize an OVDS database is found here. The database is realized using SQLite, so it is possible to use the SQLite API to read and write from it.\nHowever, an OVDS server is available that exposes a small set of methods for this, over HTTP. For more details, please check the README on the link.\nThere is as well an OVDS client available that connects to a VISSv2 server to fetch data that it then writes into the OVDS using the OVDS server interface.\nLive simulator The live simulator reads data from an OVDS containing recorded trip data, and then writes it into a state storage timed by the data time stamps so that it appears timing wise as when it was recorded. For more details, please check the README on the link.\nThe the test_vehicles.db file in the OVDS server directory contains trip data generously provided by Geotab Inc. It can be used as input to the live simulator, as well as the sawtooth_trip.db for simple testing.\nThe live simulator needs a copy of the list of leaf node paths (vsspathlist.json), which needs to contain at least all the paths that are to be replayed from the OVDS, and are also to be found in the VSS tree that the VISSv2 server uses.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/server/",
	"title": "VISSv2 Server",
	"tags": [],
	"description": "",
	"content": "The VISSv2 server is the Sw component that implements the interface that is exposed to the clients, and that must conform to the W3C VISSv2 specification.\nBuild the server Please check the chapter VISSv2 Build System for general Golang information.\nTo build the server, open a erminal and go to the WAII/server/vissv2 directory and issue the command:\n$ go build\nConfigure the server VSS tree configuration The server has a copy of the VSS tree that it uses to verify that client requsts are valid - that there is a node in the tree that corresponds to the path in a request, if a node requires an access control token, etc. The tree parser that is used expects the tre to have the \u0026lsquo;binary format\u0026rsquo; that one of the VSS-Tools genertes from the vspec files. To generate this the VSS repo must be cloned including the VSS-Tools submodule, and a file containing the binary representation must be created, which is done with the following command issued in the root directory.\n$ make binary\nThis generates a file with a name like \u0026lsquo;vss_rel_4.1-dev.binary\u0026rsquo;, which then needs to be renamed to \u0026lsquo;vss_vissv2.binary\u0026rsquo; and stored in the WAII/server/vissv2server directory.\nIf you want to configure the tree to include access control, access control tags as described in the VISSv2 - Access Control Selection chapter needs to be added to appropriate tree nodes. This can either be done by editing vspec files directly, or using the VSS-Tools overlay mechanism.\nCommand line configuration The server has the following command line configurations:\nData storage implementation. Select either to use an SQLite implementation (-s sqlite) or a Redis implementation (-s redis). Default is SQLite. Data storage file name (\u0026ndash;dbfile \u0026lsquo;file-name\u0026rsquo;). Only relevant for SQLite configuration. Default is \u0026ldquo;serviceMgr/statestorage.db\u0026rdquo;. Request the server to generate a pathlist file, then terminate (\u0026ndash;dryrun). Default is not to terminate after generating it. Pathlist file name (\u0026ndash;vssjson \u0026lsquo;file-name\u0026rsquo;. Default is \u0026ldquo;../vsspathlist.json\u0026rdquo;. UDS path for history control (\u0026ndash;uds \u0026lsquo;file-name\u0026rsquo;). Name of the Unix domain socket file. Default is \u0026ldquo;/var/tmp/vissv2/histctrlserver.sock\u0026rdquo;. Level of logging (\u0026ndash;loglevel levelx). Levelx is one of [trace, debug, info, warn, error, fatal, panic]. Default is \u0026ldquo;info\u0026rdquo;. Whether logging should end up in standard output (false) or in a log file (true) (\u0026ndash;logfile false/true). The default is \u0026lsquo;false\u0026rsquo;. Data storage configuration Currently the server supports two different databases, SQLite and Redis, which one to use is selected in the command line configuration. However, to get it up and running there are other preparations lso needed, please see the VISSv2 Data Storage chapter.\nProtocol support configuration The server supports the following protocols:\nHTTP Websockets MQTT (with the VISSv2 specific application protocol on top) gRPC The message payload is identical for all protocols at the client application level (after protocol specific payload modifications are restored). HTTP differs in that it does not support subscribe requests.\nThe code is structured to make it reasonably easy to remove any of the protocols if that is desired for reducing the code footprint. Similarly it should be reasonably straight forward to add new protocols, given that the payload format transformation is not too complicated.\nThe Websocket protocol manager terminates subscriptions if a client terminats the session without first terminating its ongoing subscriptions.\nTLS configuration The server, and several of the clients, can be configured to apply TLS to the protocols (MQTT uses it integrated model for this). The first step in applying TLS is to generate the credentials needed, which is done by running the testCredGen.sh script found here.\nFor details about it, please look at the README in that directory. As described there, the generated credentials must then be copied into the appropriate directories for both the server and the client. And the key-value \u0026ldquo;transportSec\u0026rdquo; in the transportSec.json file must be set to \u0026ldquo;yes\u0026rdquo; on both sides.\nReverting to non-TLS use only requires the \u0026ldquo;yes\u0026rdquo; to be changed to \u0026ldquo;no\u0026rdquo;, on both the server and the client side. Clients must also change to the non-TLS port number according to the list below.\nProtocol Port number: No TLS Port number: TLS HTTP 8888 443 WebSocket 8080 6443 MQTT 1883 8883 gRPC 5000 5443 Pathlist file generation Some software components that are used in the overall context to setup and run a VISSv2 based communication tech stack needs a list of all the leaf node paths of the VSS tree being used y the server. The server generates such a list at startup, in the form of a sorted list in JSON format, having a default name \u0026ldquo;vsspathlist.json\u0026rdquo;. As this file may need to be copied and used in other preparations before starting the entire tech stack, it is possible to run the server to only generate this file and then terminate. SwCs that use this file:\nSQLite state storage manager. The server itself if started to apply path encoding using some of the experimental compression schemes, and the corresponding client. The protobuf encoding scheme. The live simulator. History control The VISSv2 specification provides a capability for clients to issue a request for historic data. This server supports temporary recording of data that can then be requested by a client using a history filter. The model used in the implementation of this is that it is not the server that decides when to start or stop a recording, or how long to keep the recorded data, but it is controlled by some other vehicle system via a Unix domain socket based API. For more information, please see the service manager README.\nTo test this functionality there is a rudimentary history control client that can be used to instruct the server to start/stop/delete recording of signals. To reduce the amount of data that is recorded the server only saves a data value if it has changed compared to the latest captured, so to record more than a start and stop value the signals should be dynamic during a test.\nIgnition life cycle Dynamic data handled by the server, such as subscriptions, and access token caching, does not survive between ignition cycles (restart of the server).\nExperimental compression VISSv2 uses JSON as the payload format, and as JSON is a textbased format there is a potential to reduce the payload size by using compression.\nA first attempt on applying compression built on a proprietary algorithm that took advantage of knowing the VISSv2 payload format. This yielded compressions rates around 5 times (500%), but due to its strong dependence on the payload format it was hard to keep stable when the payload format evolved. The compression client can be used to test it out, but some payoads will likely crash it.\nA later compression solution was built on protobuf, using the VISSv2messages.proto file found here. For more details, see the compression client.\nThe gRPC protocol implementation, which requires that payloads are protobuf encoded, uses the VISSv2.proto file found here.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/",
	"title": "W3C Vehicle Information Service Specification ver 2 Reference Implementation Tutorial",
	"tags": [],
	"description": "",
	"content": "W3C Vehicle Information Service Specification ver 2 Reference Implementation Tutorial The W3C VISSv2 specification, soon to become a W3C standard, is developed at the W3C/automotive github. A reference implementation in the form of a server that exposes an interface according to the specification is developed on this repo.\nAlso found on this repo are implementations of other components that are needed to realize a communication tech stack that reaches from clients through the server and to the underlying vehicle system interface.\nThese software components (SwCs) can be categorized as follows:\nserver clients data storage feeders tools The tutorial describes each SwC category in a separate chapter. It also contains a few Proof of concept (POC) examples, and information about installing, building and running Golang based SwCs, a Docker containerization, and about some peripheral components.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/build-system/",
	"title": "WAII Build System",
	"tags": [],
	"description": "",
	"content": "Installing Golang Most of the code at this repository is written in Golang, so in order to use this repo Golang must be installed on the computer.\nSearching for \u0026ldquo;install golang\u0026rdquo; gives many hits, of which this is one:\nHow to install Go (golang) on Ubuntu Linux.\nFor other operating systems this may be helpful.\nThis project requires Go version 1.13 or above, make sure your GOROOT and GOPATH are correctly configured. Since this project uses Go modules all dependencies will automatically download when building the project the first time.\nBuilding and running As several of the Golang based Sw components on this repo can be started with command line input to configure its behavior, it is suitable to first build it (in the directory of the source code)\n$ go build\nIf the image is to be run on another platform, golang has ample cross-compilation capabilities, more can be learned here. To cross-compile, the command could look like the below.\nenv GOOS=linux GOARCH=arm64 go build -o vissv2server\nTo run it the command looks like:\n$ ./\u0026rsquo;name-of-executable\u0026rsquo; \u0026lsquo;any-command-line-config-input\u0026rsquo;\nIf the SwC supports command line configuration input it is possible to add \u0026ldquo;-h\u0026rdquo; (no quotes) on the command line, which will then show a help text. Checking the first lines of the main() function in the source code is another possibility to find out. If there is any calls to the \u0026ldquo;github.com/akamensky/argparse\u0026rdquo; lib then it is used.\nAs the configurations have a default it is always possible to run it without adding any comand line configuration input. The configuration possibilities of the different SwCs are described in the respective chapters of this tutorial.\nThe server consists of several \u0026ldquo;actors\u0026rdquo;, see the README Overview chapter. These used to be built as separate processes that communicated over the Websockets protocol. To simplify the building process of thesesoftware components the script W3CServer.sh was created. After the refactoring of these SwCs into one process with ech actor running as a separate thread, it became more convenient to build without this script, but it is still avaliable. For more details, see the \u0026ldquo;Multi-process vs single-process server implementation\u0026rdquo; chapter in the README.\nThere are multiple Software components on this repo, such as feeders, simulators, the DCT tool that are to be built as separate excutables. If it is forgotten to be mentiond in the README, one way of determining whether a separate build is needed or not is to check the package statement in the source code. If it says \u0026ldquo;package main\u0026rdquo; it is a separate executable and shall then be built and run as described above.\nLoggging Logging can be command line configured at startup.\nlogging level can be set to either of [trace, debug, info, warn, error, fatal, panic]. logging output destination. It can either be written to file, or directed to standard output. The levels currently used are mainly info, warn, error. Info is appropriate during testing and debugging, while error is appropriate when performance is important. Go modules Go modules are used in multiple places in this project, below follows some commands that may be helpful in managing this.\n$ go mod tidy To update the dependencies to latest run\n$ go get -u ./... If working with a fix or investigating something in a dependency, you can have a local fork by adding a replace directive in the go.mod file, see below examples.\nreplace example.com/some/dependency =\u0026gt; example.com/some/dependency v1.2.3 replace example.com/original/import/path =\u0026gt; /your/forked/import/path replace example.com/project/foo =\u0026gt; ../foo For more information see https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive\nDocker The server can also be built and launched using docker and docker-compose, see the Docker README. Current example builds and runs using the redis state storage together with an implementation of the feeder interfacing the remotiveLabs broker in the cloud.feeder-rl .\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/datastore/",
	"title": "WAII Data Storage",
	"tags": [],
	"description": "",
	"content": "Two realizations of data storage are available on the COVESA/CCS-components Github, one using an SQLite database, and the other a Redis database.\nThe server implements the APIs to both of these databases, which to use is selected by its command line configuration.\nThe same support should be available on the other SwC that accesses the data storage, however the current feeder implementation only implements Redis support, hence it is not merged into the master branch but resides on the feeder branch.\nIt may be a bit confusing that sometimes this is referred to as \u0026ldquo;data store/storage\u0026rdquo; and sometimes \u0026ldquo;state storage\u0026rdquo;. The latter name is legacy from a previous COVESA project, the Cloud \u0026amp; Connected Services project, while the former has emerged later in the COVESA architecture group work. An argument for keeping both could be to say that the state storage refers to a storage that only keeps the latest value of a signal, while the data store refers to a more general database that can also keep time series of values of a signal. There are two scenarios where the VISSv2 server operates on time series data, curve logging, and historic data, but in this server implementation these data series is temporarily stored within the server, so a \u0026ldquo;state storage\u0026rdquo; functionality is sufficient for its needs.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/feeder/",
	"title": "WAII Feeders",
	"tags": [],
	"description": "",
	"content": "A feeder is a Sw component that needs to implement three tasks:\nImplement an interface to the data storage Implement an interface to the underlying vehicle interface Translate data from the format used in the \u0026ldquo;VSS domain\u0026rdquo; to te format used in the \u0026ldquo;Vehicle domain\u0026rdquo;. The SW architecture shown in figure 1 reflects the division of the three tasks in that the translation (map \u0026amp; scale) is done in the min process, which spawns two threads that implement the respective interface task. The architecture shown handle all its communication with the server via the state storage. This leads to a polling paradigm and thus a potential latency and performance weakness. This architecture is therefore not found on the master branch, but available on the datastore-poll branch. Figure 1. Feeder software architecture unoptimized polling An improved architecture that eliminates the mentioned weaknesses for data flowing in the direction from the server to the feeder (i. e client write requests) is shown in figure 2. For write requests the server communicates directly over an IPC channel with the feeder, thus removing the need for the feeder to poll the state storage to find new write requests. Figure 2. Feeder software architecture optimized polling A feeder implementing the optimized polling version of the SwA is found at the master branch. This feeder can be configured to either use an SQLite, or a Redis state storage interface, please see the Datastore chapter for details.\nA design for how the polling on the server side can be mitigated is in the planning stage. It is likely to require an update of the feeder interface.\nThe feeder translation task is divided into a mapping of the signal name, and a possible scaling of the value. The instructions for how to do this is encoded into one or more configuration files that the feeder reads at startup. There are two versions of the feeder instructions, being used in template feederv1 and feederv2, respectively.\nIn version 1 this file only contains a signal name mapping, while version 2 supports also scaling instructions. For more about the telpate feeders, see the README in feeder-template directory.\nAn OEM wanting to deploy the VISSv2 tech stack needs to implement the Vehicle interface of the feeder, e. g. to implement a CAN bus interface. In the template feeders the Vehicle interface contains a minimal signal simulator that generates random values for the signals it is configured to support. All of that code should be removed and replaced by the code implementing the new interface client.\nBesides the feeder templates there is also an rl-feeder where the Vehicle interface is implemented to connect to a RemotiveLabs broker. RemotiveLabs has a public cloud version of its broker that can be used to replay trip data available in VSS format.\nThere is also an External Vehicle Interface Client EVIC feeder that enables the interface client to be implemented in a separate executable.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/pocs/",
	"title": "WAII POCs",
	"tags": [],
	"description": "",
	"content": "The WAII communication tech stack architecture can be realized in different \u0026ldquo;flavors\u0026rdquo;, a few different are presented here as Proof-of-Concept (POC) projects.\nPOC1: Vehicle.Speed subscription example POC2: Next POC.. "
},
{
	"uri": "https://w3c.github.io/automotive-viss2/datastore/redis/",
	"title": "WAII Redis",
	"tags": [],
	"description": "",
	"content": "Redis state storage When a Redis database is used as the state storage then there is no explicit database file to handle as the database is managed in-memory by the Redis daemon. Instead it is necessary to configure and launch the daemon. This is already configured in the redis/redisNative.conf that is used as input in the bash command in the server/viss2server/redisNativeInit.sh file that is called at server startup.\nTo avoid multiple daemons being started, the server checks if the daemon is already running before starting an instance of it. If there is a need to stop a running daemon, first find the daemon pid with the command\n$ ps -A | grep \u0026ldquo;redis\u0026rdquo;\nthen remove it with the command\n$ kill pid\nwhere pid comes from the result of the first command.\nCommunication with the Redis daemon is for security reasons configured to use Unix domain sockets. This requires that the socket file, and the directory it is stored in exist. If not then create it with the commands\n$ makedir path-to-socket-file-directory\n$ touch socket-file-name\nAlternative Redis server initiation If there is a need to start the Redis server a different way than what is described above then the redisInit.go file on this link will configure and launch it. The server code starting the daemon would first need to be commented out to avoid multiple instantiations.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/datastore/sqlite/",
	"title": "WAII SQLite",
	"tags": [],
	"description": "",
	"content": "SQLite state storage When an SQLite database is used as the state storage it is necessary to prepopulate it with one row for each VSS treeleaf node, having the path name as the key. To do this there is a statestorage_mgr that takes a file containing a list of all the pathnames, \u0026ldquo;vsspathlist.json\u0026rdquo; as input. This file is generated by the server at startup, taking the paths from the VSS tree that it has access to.\nThis SQLite DB file then needs to be moved to the WAII/server/visv2server/serviceMgr directory, where it should have the name \u0026ldquo;statestorage.db\u0026rdquo; (if server configuration is not changed to another name).\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/tools/",
	"title": "WAII Tools",
	"tags": [],
	"description": "",
	"content": "SwCs categorized as tools are used \u0026ldquo;off-line\u0026rdquo; to create artefacts that can then be used by the \u0026ldquo;on-line\u0026rdquo; SwCs such as the server or by feeders.\nDomain Conversion Tool The DCT creates the following:\nTwo files used by a feeder for instructions on how to convert signals between the northbound domain and a southbound domain. A file containing a YAML representation of the northbound domain, to be usd as input to the VSS-Tools binary exporter. The input to the DCT are three files: A YAML representation of signals of a northbound domain. A YAML representation of signals of a southbound domain. A YAML representation of pairs of signals from respective domain that the feeder should convert between. For more information plese see the README in the DCT directory. VSS-Tools Binary Exporter The VSS-Tools binary exporter is one of the exporters of the COVESA/VSS-Tools repo.\nHowever, running the tool is easiest done from the COVESA/VSS repo. After cloning the repo (make sure the VSS-Tools is included as a submodule) the binary exporter is run by issuing the command:\nmake binary in the root directory.\nHowever, that will create a binary format representation of the VSS standard tree. If the binary exporter is to take another data model as input the make file will need to be modified. The make file line related to the binary exporter that points to the input file (the last line below):\nbinary: gcc -shared -o ${TOOLSDIR}/binary/binarytool.so -fPIC ${TOOLSDIR}/binary/binarytool.c ${TOOLSDIR}/vspec2binary.py --uuid -u ./spec/units.yaml ./spec/VehicleSignalSpecification.vspec vss_rel_$$(cat VERSION).binary needs to be modified to point to the desired file, i.e. the part \u0026ldquo;./spec/VehicleSignalSpecification.vspec\u0026rdquo; needs to be changed.\nThe tool output, a file with the extension \u0026ldquo;.binary\u0026rdquo; will then have to be copied to the WAII server directory, and renamed to \u0026ldquo;vss_vissv2.binary\u0026rdquo;.\n"
}]