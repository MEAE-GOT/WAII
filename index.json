[
{
	"uri": "https://w3c.github.io/automotive-viss2/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://w3c.github.io/automotive-viss2/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://w3c.github.io/automotive-viss2/pocs/poc1/",
	"title": "VISSv2 (POC1, replace by more expressive name)",
	"tags": [],
	"description": "",
	"content": "The presentation\u0026hellip;\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/server/access-control-servers/",
	"title": "VISSv2 Access Control Servers",
	"tags": [],
	"description": "",
	"content": "The VISSv2 access control model specifies two authorization servers:\nAccess Grant server Access Token server Access Grant server This server is in a typical scenario running in the cloud. It is built as a separate executable in the WAII/server/agt_server directory\n$ go build\nand run by\n$ ./agt_server\nIt exposes an HTTP API according to the VISSv2 specification. However it is currently not TLS protected (which is a must in non-development scenario). What is also missing in the AGS implementation is authentication of the client, which according to the specification should be an AGT task.\nAccess Token server This server runs as a thread within the vissv2 server, so it is built by the vissv2 build command. For it to be built, it is necessary to make sure that the \u0026ldquo;atServer\u0026rdquo; line in the serverComponents array in the vissv2server.go code is uncommented:\nvar serverComponents []string = []string{ \u0026#34;serviceMgr\u0026#34;, \u0026#34;httpMgr\u0026#34;, \u0026#34;wsMgr\u0026#34;, \u0026#34;mqttMgr\u0026#34;, \u0026#34;grpcMgr\u0026#34;, \u0026#34;atServer\u0026#34;, } If it is part of the vissv2server build, and if a VSS node is access control tagged, the server will then forward the access token received in the client request to the ATS for validation.\nThe ATS will as part of the validation also use the VISSv2 specified policy documents if they are found in the working directory.\nVISS web client submodule This submodule implements a VISSv2 web client that exposes a UI that is considerably more sophisticated than what other clients on the WAII repo exposes, and it is particularly helpful when it comes to the client interactions with access control involved. Check out the README on both repos for more information.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/build-system/",
	"title": "VISSv2 Build System",
	"tags": [],
	"description": "",
	"content": "Installing Golang Most of the code at this repository is written in Golang, so in order to use this repo Golang must be installed on the computer.\nSearching for \u0026ldquo;install golang\u0026rdquo; gives many hits, of which this is one:\nHow to install Go (golang) on Ubuntu Linux.\nFor other operating systems this may be helpful.\nBuilding and running As several of the Golang based Sw components on this repo can be started with command line input to configure its behavior, it is suitable to first build it (in the directory of the source code)\n$ go build\nand then run it\n$ ./\u0026rsquo;name-of-executable\u0026rsquo; \u0026lsquo;any-command-line-config-input\u0026rsquo;\nIf the SwC supports command line configuration input it is possible to add \u0026ldquo;-h\u0026rdquo; (no quotes) on the command line, which will then show a help text. Checking the first lines of the main() function in the source code is another possibility to find out. If there is any calls to the \u0026ldquo;github.com/akamensky/argparse\u0026rdquo; lib then it is used.\nAs the configurations have a default it is always possible to run it without adding any comand line configuration input. The configuration possibilities of the different SwCs are described in the respective chapters of this tutorial.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/client/",
	"title": "VISSv2 Clients",
	"tags": [],
	"description": "",
	"content": "There is a number of different clients avaliable on this repo undr the directory Clients.\nJava based clients Golang based clients "
},
{
	"uri": "https://w3c.github.io/automotive-viss2/datastore/",
	"title": "VISSv2 Data Storage",
	"tags": [],
	"description": "",
	"content": "Two realizations of data storage are available on the COVESA/CCS-components Github, one using an SQLite database, and the other a Redis database.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/feeder/",
	"title": "VISSv2 Feeder",
	"tags": [],
	"description": "",
	"content": "A feeder is a Sw component that has three purposes:\nImplement an interface to the data storage Implement an interface to the underlying vehicle interface Translate data from the format used in the \u0026ldquo;VSS domain\u0026rdquo; to te format used in the \u0026ldquo;Vehicle domain\u0026rdquo;. "
},
{
	"uri": "https://w3c.github.io/automotive-viss2/pocs/",
	"title": "VISSv2 POCs",
	"tags": [],
	"description": "",
	"content": "The communication tech stack architecture can be realized in different \u0026ldquo;flavors\u0026rdquo;, and here a few different are presented.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/server/",
	"title": "VISSv2 Server",
	"tags": [],
	"description": "",
	"content": "The VISSv2 server is the Sw component that implements the interface that is exposed to the clients, and that must conform to the W3C VISSv2 specification.\nBuild the server Please check the chapter VISSv2 Build System for general Golang information.\nTo build the server, open a erminal and go to the WAII/server/vissv2 directory and issue the command:\n$ go build\nConfigure the server VSS tree configuration The server has a copy of the VSS tree that it uses to verify that client requsts are valid - that there is a node in the tree that corresponds to the path in a request, if a node requires an access control token, etc. The tree parser that is used expects the tre to have the \u0026lsquo;binary format\u0026rsquo; that one of the VSS-Tools genertes from the vspec files. To generate this the VSS repo must be cloned including the VSS-Tools submodule, and a file containing the binary representation must be created, which is done with the following command issued in the root directory.\n$ make binary\nThis generates a file with a name like \u0026lsquo;vss_rel_4.1-dev.binary\u0026rsquo;, which then needs to be renamed to \u0026lsquo;vss_vissv2.binary\u0026rsquo; and stored in the WAII/server/vissv2server directory.\nIf you want to configure the tree to include access control, access control tags as described in the VISSv2 - Access Control Selection chapter needs to be added to appropriate tree nodes. This can either be done by editing vspec files directly, or using the VSS-Tools overlay mechanism.\nCommand line configuration The server has the following command line configurations:\nData storage implementation. Select either to use an SQLite implementation (-s sqlite) or a Redis implementation (-s redis). Default is SQLite. Data storage file name (\u0026ndash;dbfile \u0026lsquo;file-name\u0026rsquo;). Only relevant for SQLite configuration. Default is \u0026ldquo;serviceMgr/statestorage.db\u0026rdquo;. Request the server to generate a pathlist file, then terminate (\u0026ndash;dryrun). Default is not to terminate after generating it. Pathlist file name (\u0026ndash;vssjson \u0026lsquo;file-name\u0026rsquo;. Default is \u0026ldquo;../vsspathlist.json\u0026rdquo;. UDS path for history control (\u0026ndash;uds \u0026lsquo;file-name\u0026rsquo;). Name of the Unix domain socket file. Default is \u0026ldquo;/var/tmp/vissv2/histctrlserver.sock\u0026rdquo;. Level of logging (\u0026ndash;loglevel levelx). Levelx is one of [trace, debug, info, warn, error, fatal, panic]. Default is \u0026ldquo;info\u0026rdquo;. Whether logging should end up in standard output (false) or in a log file (true) (\u0026ndash;logfile false/true). The default is \u0026lsquo;false\u0026rsquo;. Data storage configuration To be written\u0026hellip;\nProtocol support configuration The server supports the following protocols:\nHTTP Websockets MQTT (with the VISSv2 specific application protocol on top) gRPC The message payload is identical for all protocols at the client application level (after protocol specific modifications are restored).\nThe code is structured to make it reasonably easy to remove any of the protocols if that is desired for reducing the code footprint. Similarly it should be reasonably straight forward to add new protocols, given that the payload format transformation is not too complicated.\n"
},
{
	"uri": "https://w3c.github.io/automotive-viss2/",
	"title": "W3C Vehicle Information Service Specification ver 2 Reference Implementation Tutorial",
	"tags": [],
	"description": "",
	"content": "W3C Vehicle Information Service Specification ver 2 Reference Implementation Tutorial The W3C VISSv2 specification, soon to become a W3C standard, is developed at the W3C/automotive github. A reference implementation in the form of a server that exposes an interface according to the specification is developed on this repo.\nAlso found on this repo are implementations of other components that are needed to realize a communication tech stack that reaches from clients through the server and to the underlying vehicle system interface.\nThese software components (SwCs) can be categorized as follows:\nserver client data storage feeder The tutorial describes each SwC in a separate chapter. It also contains a few Proof of concept (POC) examples, and information about installing, building and running Golang based SwCs.\n"
}]